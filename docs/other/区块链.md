- [1. 区块链基础知识](#1-区块链基础知识)
  - [1.1. 比特币 私匙 公匙 地址](#11-比特币-私匙-公匙-地址)
  - [1.2. 比特币交易本质和流程](#12-比特币交易本质和流程)
  - [1.3. 比特币多重签名](#13-比特币多重签名)
  - [1.4. Segwit 隔离见证地址](#14-segwit-隔离见证地址)
  - [1.5. HD钱包](#15-hd钱包)
  - [1.6. MPT](#16-mpt)
  - [1.7. 合约](#17-合约)
    - [1.7.1. ERC20 代币](#171-erc20-代币)
    - [1.7.2. ERC777](#172-erc777)
    - [1.7.3. ERC721](#173-erc721)
  - [1.8. gas, gas price, gas limit](#18-gas-gas-price-gas-limit)
- [2. Solidity 合约编写](#2-solidity-合约编写)
  - [2.1. 一些全局变量](#21-一些全局变量)
  - [2.2. 地址类对象的方法和属性](#22-地址类对象的方法和属性)
  - [2.3. 合约函数定义相关](#23-合约函数定义相关)
  - [2.4. 交易 Transactions](#24-交易-transactions)
  - [2.5. 调用 Calls](#25-调用-calls)
  - [2.6. 调用其他合约](#26-调用其他合约)
  - [2.7. 创建合约实列](#27-创建合约实列)
  - [2.8. 估算某个方法的gas开销](#28-估算某个方法的gas开销)
  - [2.9. 类型转换](#29-类型转换)
- [3. 汇编相关代码](#3-汇编相关代码)
- [4. truffle 使用](#4-truffle-使用)
  - [4.1. 报错:Unbox failed!  Error: getaddrinfo ENOENT raw.githubusercontent.com](#41-报错unbox-failed--error-getaddrinfo-enoent-rawgithubusercontentcom)
  - [4.2. migrations](#42-migrations)
  - [4.3. 测试合约](#43-测试合约)
  - [4.4. 控制台](#44-控制台)
    - [4.4.1. 进入控制台的方式](#441-进入控制台的方式)
    - [4.4.2. truffle develop 使用](#442-truffle-develop-使用)
  - [4.5. 对于重载函数可以使用如下区分](#45-对于重载函数可以使用如下区分)
  - [4.6. @truffle/contract](#46-trufflecontract)
- [5. Geth 使用](#5-geth-使用)
  - [5.1. 同步区块](#51-同步区块)
  - [5.2. 连接geth终端](#52-连接geth终端)
- [6. web3js 使用](#6-web3js-使用)
  - [6.1. web3.eth.Contract 相关](#61-web3ethcontract-相关)
    - [6.1.1. 创建一个合约](#611-创建一个合约)
    - [6.1.2. 默认账号, 默认用于from参数](#612-默认账号-默认用于from参数)
    - [6.1.3. 一些配置信息 和 函数](#613-一些配置信息-和-函数)
    - [6.1.4. 部署合约](#614-部署合约)
    - [6.1.5. 调用合约方法 调用函数](#615-调用合约方法-调用函数)
    - [6.1.6. send方法可监听的事件](#616-send方法可监听的事件)
    - [6.1.7. 事件监听](#617-事件监听)

# 1. 区块链基础知识

## 1.1. 比特币 私匙 公匙 地址
``` 
私匙:
又称为钱包导入格式：WIF（Wallet Import Format）
使用非压缩格式的WIF是以5开头的字符串。
使用压缩格式的WIF是以K或L开头的字符串

公匙:
以1开头的地址
公匙是根据私匙由ECDSA算法推算出来的

地址:
而是公钥的哈希，即从公钥能推导出地址，但从地址不能反推公钥.
公匙经过hash160, 也就是先计算SHA-256，再计算RipeMD160得到地址
```

## 1.2. 比特币交易本质和流程
```
比特币交易的输出是一个锁定脚本，而下一个交易的输入是一个解锁脚本。必须提供一个解锁脚本，让锁定脚本正确运行，那么该输入有效，就可以花费该输出。
当小明给小红支付一笔比特币时，实际上小明创建了一个锁定脚本，该锁定脚本中引入了小红的地址。要想通过解锁脚本花费该输出，只有持有对应私钥的小红才能创建正确的解锁脚本（因为解锁脚本包含的签名只有小红的私钥才能创建），因此，小红事实上拥有了花费该输出的权利


解锁脚本(某账号的输入): 48 (30450221...68fa9b01[这个为消息的签名]) 21 (03dd8763...14cf740f[这个为公匙])
锁定脚本(某账号的输出 包含该输出要到的地址): 76 a9 14 (dc5dc65c...fe9f489c[这个为输出到账号的地址]) 88 ac
          DATA 48 (30450221...68fa9b01) [这个为消息的签名]
          DATA 21 (03dd8763...14cf740f) [这个为公匙]
        OP_DUP 76 [复制堆栈最上面的数据]
    OP_HASH160 a9 [进行hash160计算,也就是通过公匙计算地址]
          DATA 14 (dc5dc65c...fe9f489c)  [地址数据]
OP_EQUALVERIFY 88 [比较堆栈上面的2个数据是否相等]
   OP_CHECKSIG ac [验证签名消息]
```
## 1.3. 比特币多重签名
```
多重签名地址实际上是一个Script Hash
多重地址是以3开头的
发送给多重签名地址的交易创建的是P2SH脚本
而花费多重签名地址的资金需要的脚本就是M个签名+Redeem Script。

Redeem Script 包含了所有人的公钥，以及正确的M-N数值

多重签名可以实现N个人持有私钥，其中M个人同意即可花费资金的功能。

支付比特币到一个多重签名地址实际上是创建一个P2SH输出。
```


## 1.4. Segwit 隔离见证地址
```
bc开头
3开头的为隔离见证兼容地址 Nested Segwit Address
```

## 1.5. HD钱包
```
只需要管理一个根私钥，即可实时计算所有“子私钥”的管理方式，称为HD钱包。

xprv: 扩展私钥
是一个扩展的512位私钥，记作xprv，它通过SHA-512算法配合ECC计算出子扩展私钥，仍然是512位。通过扩展私钥可计算出用于签名的私钥以及公钥。

HD钱包采用分层确定性算法通过根扩展私钥计算所有层级的所有子扩展私钥，继而得到扩展公钥和地址；
可以通过普通衍生和硬化衍生两种方式计算扩展子私钥，后者更安全，但对应的扩展公钥无法计算硬化衍生的子
通过扩展公钥可以在没有扩展私钥的前提下计算所有普通子扩展公钥，此特性可实现观察钱包。

使用助记词+口令来生成HD钱包的种子，用户只需记忆助记词和口令即可随时恢复HD钱包。
```


问题:
同一时间有2个矿工找到了一个区块, 然后分叉了, 后续又因为最长工时算法, 有一个区块被废弃了, 那么被废弃了的区块上的交易记录去哪了. 那第一个挖到那个区域的矿工的奖励还会有吗?


## 1.6. MPT
```
叶子节点: 是一个键值对(key, value) key是原始内容的一种
```

## 1.7. 合约
### 1.7.1. ERC20 代币
```
1. ERC20代币: 可替代性代币的标准, 不同单元之间可以相互交换
2. 发行量可以是固定的也可以调整修改
```
### 1.7.2. ERC777
```
针对ERC20改进的代币合约
```
### 1.7.3. ERC721
```
不可替代物(实物契约)的代币标准
```

## 1.8. gas, gas price, gas limit
```
gas 为一个交易中以太坊虚拟机的实际运算步数
gas price 为你愿意为一个单位的gas出的Eth  1Gwei = 10^-9eth = 0.000000001eth
实际交易手续费 = gas(实际运行步数) * gasprice(单位价格)
```




# 2. Solidity 合约编写
## 2.1. 一些全局变量
```
1. msg
    msg.sender: 发起合约调用的以太坊地址
    msg.value: 调用方发送的以太币(wei单位)
    msg.data: 调用合约传入的数据
    msg.sig: 传输数据的前4个字节, 这是一个函数选择器
    当一个合约调用另外一个合约的时候, msg的值会发全部发生变化, 体现出新调用方的信息.可以使用delegatecall函数进行阻止该操作.
    
2. tx
    tx.graprice: 调用交易的gas价格
    tx.origin: 发起这个交易的外部账户地址, 不安全
3. block
    block.coinbase: 当前区块的矿工地址.
    block.difficulty: 当前区块的工作量证明
    block.gaslimit: 
    block.number: 区块编号
    block.timestamp: 矿工写入的时间戳
```
## 2.2. 地址类对象的方法和属性
```
address.balance
address.delegatecall() 可以用来调用库合约

```

## 2.3. 合约函数定义相关
````
定义: 
    function FunctionName(parameters){public private internal external} [pure constant view payable] [modifiers] [returns(return types)]
1. 回退函数定义的时候不需要提供名字, 在调用合约的时候没有指明函数名字时会调用的方法.
2. external 不能再合约内部调用, 除非在调用的时候用关键字this
3. internal 不能被外部调用,只能在合约内部调用, 或者派生的子合约中调用
4. private 类似internal 但是无法被当前合约派生的子合约调用.

5. constant 或 view 表示不对任何状态进行修改
6. pure 表明这个函数不会在区块链存储中读取或写入任何数据
7. payable 函数用于接收外部的支付。未声明为payable的函数不能接收任何以太币支付。但是由于EVM的设计决策,有两种意外情况:区块挖矿的奖励支付和SELFDESTRUCT的合约注销

8. 构造函数, 可以和函数同名, 或者使用关键字constructor, 在合约创建的过程中执行一次.
9. 析构函数 selfdestruct(address recipient) 参数为接收以太币的地址
10. modifier 修饰符函数 在修饰符内部, 修饰符所作用到的函数能够访问所有变量和参数。
11. 使用 is 关键字来指定父合约
    constract Child is Parent1, parent2 {
    ... 
    }
12. 错误处理 assert require 
    assert : 用来判断条件为真的情况, 一般用于合约内部。
    require: 一般用来测试输入对外部变量的期望。提供第二个参数,用来写入日志信息。
13. 事件
````

## 2.4. 交易 Transactions
```
消耗Gas 费用（以太） 
会更改网络状态 
不会立即执行（需要等待网络矿工打包） 

会返回一个res对象, 其中res.logs[0].event查看事件的名称了res.logs[0].args查看事件的参数
```

## 2.5. 调用 Calls
```
免费（不消耗 Gas） 
不改变网络状态
立即执行 
有返回值
```

## 2.6. 调用其他合约
```
send
call 危险 会把msg的上下文变成发起调用的合约
callcode 危险 将被废弃
delegatecall msg上下文保持不变 库合约也是使用这种方式调用的, 库合约代码始终运行在调用发起方的上下文


调用IThrow1函数?
address(this).call(abi.encodePacked(this.IThrow1.selector));
```

## 2.7. 创建合约实列
```
_faucet = new Faucet()
new关键字也接收可选的参数,这些参数用来指定合约创建时转入的以太币数量,以及可能需要传递给新合约构造函数的一些参数
_faucet = (new Faucet).value(0.5 ether)
使用输入传递的地址并将他们转换为特定对象, 这样做非常危险
_faucet = Faucet(_f)
```

## 2.8. 估算某个方法的gas开销
```
估算某个方法的gas开销
var contract = web3.eth.contract(abi).at(address); 
var gasEstimate = contract.myAweSomeMethod.estimateGas(arg1, arg2, {from:account});
查看某个方法的部署gas
Contract.new.estimateGas()


获取当前网格中的gas价格
var gasPrice = web3.eth.getGasPrice();

估算一个调用的gas开销
var gasCostInEther = web3.fromWei((gasEstimate * gasPrice), 'ether')


```


## 2.9. 类型转换
```
https://me.tryblockchain.org/solidity-conversions.html

address payable addr1 = msg.sender;
address addr2 = addr1; // 隐式转
address addr3 = address(addr1); // 显式转

// 直接声明一个地址
address _owner = 0xDF12793CA392ff748adF013D146f8dA73df6E304;

uint160 => address
uint160 _ownerUint = 1273516916528256943268872459582090959717186069252;
address(_ownerUint)
```

# 3. 汇编相关代码
```
1. mload 加载对应的内存地址的值. 
   在EVM中, 前6个字节为保留字节, 其中0x40-0x40中存储着可用内存地址的值
   let memValue := mload(0x04) // 将0x40处的值加载到memValue中,从0x40中加载32字节
2. mstore(p, v)  mem[p…(p+32)) := v 将数据存储到对应地址 
3. calldatacopy(t, f, s) : 从f地址复制s个bytes到t
4. calldatasize 交易调用时候的data大小, 以bytes表示
5. call callcode delegatecall 调用函数, 返回值0表示失败, 1表示成功. 调用的地址返回值存储在out地址, 大小为outsize, 使用如下可以访问返回值:
  let size := returndatasize  // 读取返回值大小
  returndatacopy(ptr, 0, size) // 将返回值copy到ptr处
```


# 4. truffle 使用
## 4.1. 报错:Unbox failed!  Error: getaddrinfo ENOENT raw.githubusercontent.com
```
替换host文件为:
199.232.68.133  raw.githubusercontent.com
```

## 4.2. migrations
```
1. artifacts.require(name) name为合约的名称

迁移为啥不重新部署一个新合约
用--reset设置后, 老的合约去哪了
```

## 4.3. 测试合约
```
1. 可以直接使用合约名字来访问合约抽象实列
2. const instance = await MyContract.deployed();可以获取合约的实列
```

## 4.4. 控制台
### 4.4.1. 进入控制台的方式
```
1. truffle console
2. truffle develop  会启动一个临时的区块链运行在 127.0.0.1:9545上
```
### 4.4.2. truffle develop 使用
```
compile
migrage
Faucet.deployed().then(i => {FaucetDeployed = i}) // 实列化了合约Faucet的地址,保存到了变量FaucetDeployed中

FaucetDeployed.send(***).then(res => {console.log(res)}) // 可以通过FaucetDeployed直接调用相关函数

```

## 4.5. 对于重载函数可以使用如下区分
```
const instance = await MyContract.deployed();
instance.methods['setValue(uint256)'](123);
instance.methods['setValue(uint256,uint256)'](11, 55);
```


## 4.6. @truffle/contract
```
* MyContract.link(instance): 链接一个合约库, 这种链接方式会消费和报告链接库中的事件
* MyContract.link(name, address) : 这种方式链接一个库,链接库中的事件不会被消费
* MyContract.link(object): 一次链接多个库{name: address, name2: address2}, 链接库中的事件不会被消费

* MyContract.setProvider(provider): 设置web3用来交易
* MyContract.defaults([new_defaults]): 设置通过该抽象合约实列化对象的默认交易值
    MyContract.defaults({
      from: ...,
      gas: ...,
      gasPrice: ...,
      value: ...
    })


* instance.setValue.call(5).then(***); 这种方式只是call不是一个transaction, 不会造成状态的改变.
* 如果一个函数被修饰为view 或者 pure 那么可以不用call来调用, 直接调用函数名. truffle自动会知道这是一个call不是transaction.

* instance.sendTransaction({}).then(result =>{}); 会触发合约的fallback函数
* instance.MyMethod.sendTransaction(); 强制某个函数调用为transaction
* instance.send(web3.toWei(1, "ether")).then(result => {}); // 只是发送eth
```



















# 5. Geth 使用
## 5.1. 同步区块
```
geth  --datadir . --syncmode fast --cache 1024

```

## 5.2. 连接geth终端
```
// 以下为连接goerli  签名使用clef 可以用其他钱包管理工具
geth --goerli --syncmode "light" --datadir . --http --signer=\\.\pipe\clef.ipc

geth --syncmode "light" --datadir . --http

geth --ropsten --syncmode "light" --datadir . --http


geth attach \\.\pipe\geth.ipc

端口: 127.0.0.1:8545 连接
```





# 6. web3js 使用
## 6.1. web3.eth.Contract 相关
### 6.1.1. 创建一个合约
```js
new web3.eth.Contract(jsonInterface[, address][, options]);

// 或者如下
var Contract = require('web3-eth-contract');
var contract = new Contract(jsonInterface, address);

// jsonInterface为合约的abi json文件
options = {
  from, // 调用的发起方
  gasPrice, //
  gas,  // 交易最大的gas上线
  data, 合约的二进制
}
```
### 6.1.2. 默认账号, 默认用于from参数
```
web3.eth.Contract.defaultAccount
contractInstance.defaultAccount
```
### 6.1.3. 一些配置信息 和 函数
```
以下web3.eth都可以替换为contractInstance

web3.eth.defaultBlock //指定区块
web3.eth.defaultHardfork
web3.eth.defaultChain // 本地签名交易的时候用的链
web3.eth.defaultCommon
web3.eth.transactionBlockTimeout // 会被用在基于套接字的连接上, 该属性定义了直到第一次确认发生的区块等待数量
web3.eth.transactionConfirmationBlocks //定义了确认交易所需要的区块确认数。
web3.eth.transactionPollingTimeout // 基于HTTP的链接 这个选项定义了 Web3 等待确认交易被网络挖出的收据的秒数。

contractInstance.options.address // 合约地址
contractInstance.copy // 复制一个合约实列
```
### 6.1.4. 部署合约
```js
contractInstance.deploy(options) // 部署一个合约
options = {
  data, // 合约的二进制代码
  arguments, // 构造函数的参数
}

返回值:
  {
    Array, // 传入的参数
    send(Function), // 部署合约, 使用该方法真正部署合约
    estimateGas(Function), // 估算部署要的gas
    encodeABI(Function), // 
  }

demo:
myContract.deploy({
    data: '0x12345...',
    arguments: [123, 'My String']
})
.send({
    from: '0x1234567890123456789012345678901234567891',
    gas: 1500000,
    gasPrice: '30000000000000'
}, function(error, transactionHash){ ... })
.on('error', function(error){ ... })
.on('transactionHash', function(transactionHash){ ... })
.on('receipt', function(receipt){
   console.log(receipt.contractAddress) // 包含新合约地址
})
.on('confirmation', function(confirmationNumber, receipt){ ... })
.then(function(newContractInstance){
    console.log(newContractInstance.options.address) // 带有新合约地址的合约实例
});
```

### 6.1.5. 调用合约方法 调用函数
```js
1. contractInstance.methods.myMethod([param1[, param2[, ...]]])

2. 以下3种方法都可以访问合约函数
   * 方法名: myContract.methods.myMethod(123)
   * 带参数的方法名: myContract.methods['myMethod(uint256)'](123)
   * 方法签名: myContract.methods['0x58cf5f10'](123)


3. 返回值
   object = {
     Array,
     call(Function),
     send(Function),
     estimateGas(Function),
     encodeABI(Function)
   }

4. demo
和使用deploy方法不同, send方法返回的是receipt
send后可以监听事件

myContract.methods.myMethod(123).call({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'}, function(error, result){
    ...
});

// 或者发生交易并使用 promise
myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
.then(function(receipt){
    // receipt can also be a new contract instance, when coming from a "contract.deploy({...}).send()"
});

// 或者发送交易并使用事件
myContract.methods.myMethod(123).send({from: '0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe'})
.on('transactionHash', function(hash){
    ...
})
.on('receipt', function(receipt){
    ...
})
.on('confirmation', function(confirmationNumber, receipt){
    ...
})
.on('error', function(error, receipt) {
    ...
});
```

### 6.1.6. send方法可监听的事件
```
sending: 在发送交易请求之前触发
  返回值: object
sent: 在发送交易请求且transaction hash未接收到的时候触发
  返回值: object
transactionHash : transaction hash生成了
  返回值: transactionHash: String
receipt:
  返回值: object
confirmation: 每次被确认都会被触发, 会触发24次
  返回值: confirmation: number, receipt:object
error: 
  返回值: error, receipt
```


### 6.1.7. 事件监听
```
myContract.once('MyEvent', {
    filter: {myIndexedParam: [20,23], myOtherIndexedParam: '0x123456789...'}, 
    // 使用数组表示 或：比如 20 或 23。
    fromBlock: 0
}, function(error, event){ console.log(event); });
```


